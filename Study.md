# Day1

**前置知识**

OpenGL一般被认为是一个图形API，然而，OpenGL本身并不是一个API，它仅仅是一个由[Khronos组织](http://www.khronos.org/)制定并维护的规范。实际的OpenGL库的开发者通常是显卡的生产商，这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。



**核心模式和立即渲染模式**

早期的OpenGL使用立即渲染模式，即固定渲染管线。它确实容易使用和理解，但是效率太低！

OpenGL3.2开始，规范文档开始废弃立即渲染模式，鼓励开发者在OpenGL核心模式下开发。

当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数，现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。



**状态机**

OpenGL自身是一个巨大的状态机，一系列的变量描述OpenGL此刻应当如何运行，这些状态集合称为OpenGL上下文（Context）。



**创建窗口**

渲染出内容，第一步：创建一个OpenGL上下文和一个用于显示的窗口。

这些操作在每个系统上都是不一样的，OpenGL有意将这些操作抽象(Abstract)出去。所以我们需要利用现成的一些库来完成这些最基本的平台相关代码，节省时间！

流行的有：GLUT、SDL、SFML、GLFW

对比一下：

**GLUT**: 适合学习和简单的 OpenGL 应用，功能有限，已停止更新。

**SDL**: 功能全面，适合游戏和多媒体应用开发，支持多种平台。

**SFML**: API 简洁，功能丰富，适用于 2D 图形、多媒体和游戏开发。

**GLFW**: 轻量级，专注于 OpenGL 窗口和输入管理，适合 OpenGL 应用。







**GLAD**

因为OpenGL只是一个标准，具体的实现是由驱动开发商实现。

由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。

所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。

类似如下：

```
// 定义函数原型
typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);
// 找到正确的函数并赋值给函数指针
GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress("glGenBuffers");
// 现在函数可以被正常调用了
GLuint buffer;
glGenBuffers(1, &buffer);
```

幸运的是，GLAD就是简化此过程的库，也是最流畅最新的！





**你好窗口**



**你好三角形**

先记住三个单词：

- VAO（顶点数组对象）
- VBO（顶点缓冲对象）
- IBO（索引缓冲对象） or EBO



图形渲染管线：

3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线处理，它们可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化，很容易并行执行！

GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在快速处理你的数据。这些小程序叫做Shader！

OpenGL着色器是用OpenGL着色器语言（GLSL）编写。

渲染管线抽象如下图所示：

![image-20240624225948825](./Study.assets/image-20240624225948825.png)



蓝色表示可自定义阶段，灰色表示固定阶段！



现代OpenGL中，我们**必须**定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。

OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理。

这个范围内的坐标叫NDC坐标！此范围内的坐标最终显示在屏幕上！



**VBO**

顶点缓冲对象是我们在[OpenGL](https://learnopengl-cn.github.io/01 Getting started/01 OpenGL/)教程中第一个出现的OpenGL对象，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次！



OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型！



**VAO**

绑定针对VBO的顶点数据的属性描述集合，如下图：

![image-20240624232514532](./Study.assets/image-20240624232514532.png)



最常见的渲染之前设置状态语句：

- glUseProgram(shaderProgram); 
- glBindVertexArray(VAO); 
- glDrawArrays(GL_TRIANGLES, 0, 3);



**EBO**

可以理解为一种特殊的VBO，它只是存储构成绘制图元的顶点索引序列而已！它和VAO、VBO关系如下：

![image-20240624233843496](./Study.assets/image-20240624233843496.png)



**着色器**

着色器(Shader)是运行在GPU上的小程序

典型的GLSL代码结构：

```glsl
#version version_number
in type in_variable_name;
in type in_variable_name;

out type out_variable_name;

uniform type uniform_name;

int main()
{
  // 处理输入并进行一些图形操作
  ...
  // 输出处理过的结果到输出变量
  out_variable_name = weird_stuff_we_processed;
}
```



能声明的顶点属性是有上限的，由硬件决定。OpenGL确保至少有16个包含4分量的顶点属性可用！

通过一下Code片段可查询：

```glsl
int nrAttributes;
glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);
std::cout << "Maximum nr of vertex attributes supported: " << nrAttributes << std::endl;
```



**GLSL语言介绍：**

基础数据类型：

- int
- float
- double
- uint
- bool

向量类型：

- vecn（float）
- bvecn（bool）
- ivecn（int）
- uvecn（unsigned int）
- dvecn（double）



向量的分量访问：

- .x | .y | .z | .w
- .r | .g | .b | .a
- .s | .t | .p | .q

灵活的方式：重组（swizzling），如下：

- xyzz
- xxx
- xy





`layout (location = 0)`  表示：

顶点着色器为它的输入提供一个额外的`layout`标识，这样我们才能把它链接到顶点数据。





如果我们打算从一个着色器向另一个着色器发送数据：

- 发送方着色器中声明一个输出
- 接收方着色器中声明一个类似的输入
- 类型和名字都一样





**Uniform**

Uniform是另一种从我们的应用程序在 CPU 上传递数据到 GPU 上的着色器的方式。

它是全局的，它在每个着色器程序对象中独一无二，而且可以被着色器程序的任意着色器在任意阶段访问。





# Day2

**纹理**

如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。纹理就是提供颜色的工具！

纹理是一个2D图片（甚至也有1D和3D的纹理），可以把他想象成贴纸，贴到你所需要的位置！



**纹理Wrap方式**

纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？问题的答案就是Wrap方式

OpenGL提供4个：

- GL_REPEAT (重复)
- GL_MIRRORED_REPEAT (重复镜像)
- GL_CLAMP_TO_EDGE (边缘拉伸)
- GL_CLAMP_TO_BORDER (指定超出部分颜色)

![image-20240625095154680](Study.assets/image-20240625095154680.png)





**纹理过滤**

纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素映射到纹理坐标！

最常见的就两种：最邻近插值、线性插值



- 最邻近插值（选择中心点最接近纹理坐标的那个像素）
- 线性插值（基于纹理坐标附近的纹理像素，计算出一个插值，近似）



如果图片分辨率过低，使用最邻近的像素效果就比较严重，使用线性插值会产生模糊效果

![image-20240625095532544](Study.assets/image-20240625095532544.png)





**多级渐进纹理（Mipmap）**

我们都知道，距离的远近，会导致最终显示在屏幕的像素产生非常大的不同！如果显示区域非常小，就类似产生纹理特别大的情况，这时候获取像素值就非常不真实，会产生摩尔纹！

OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题。简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。

多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个！

由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。

**Mipmap类似如下：**

![image-20240625095946199](Study.assets/image-20240625095946199.png)



**Mipmap切换**

OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。因此产生四种过滤方式：

- GL_NEAREST_MIPMAP_NEAREST （前面表示采样方式，后面表示Mipmap切换过滤方式。这就表示最近邻匹配mipmap，最邻近采样纹理）
- GL_LINEAR_MIPMAP_NEAREST
- GL_NEAREST_MIPMAP_LINEAR
- GL_LINEAR_MIPMAP_LINEAR





**常见错误：**将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果！







**加载和创建纹理**

使用纹理之前要做的第一件事是把它们加载到我们的内存中。所以我们需要一个加载器！这里选用stb_image库！





## 变换

齐次坐标：x、y、z、w

位置向量：w=1

方向向量：w=0



**万向节死锁的本质：**只能按照规定的三个轴顺序依次旋转！

四元数如何解决！





**GLM**

OpenGL没有自带任何的矩阵和向量，专门为OpenGL量身定做的数学库，那就是GLM！

GLM的大多数功能都可以从下面这3个头文件中找到：

```
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
```







## 坐标系统

OpenGL希望在每次顶点着色器运行后，可见的所有顶点都为标准化设备坐标（NDC）。

每个顶点的**x**，**y**，**z**坐标都应该在**-1.0**到**1.0**之间，超出这个坐标范围的顶点都将不可见。



物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统，优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易！

比较重要的总共有5个不同的坐标系统：

- 局部空间
- 世界空间
- 观察空间
- 裁剪空间
- 屏幕空间





**局部空间**

最开始的坐标，一般指建模软件导出的原始坐标



**世界空间**

永恒不变的坐标系



**观察空间**

经过视图变换后的坐标



**裁剪空间**

观察空间坐标 + 投影矩阵 + 透视除法 + Clip 



**屏幕空间**

glViewPort 指定屏幕空间变换矩阵





Z-**buffer**

深度测试，就是保证前后正确的遮挡关系！





## 摄像机

本质就是构造观察矩阵View，通过交互改变这个View模拟出一种摄像机的感觉！



这里重点讨论FPS风格的摄像机！



**摄像机的参数：**

- 位置（vec3）
- 观察方向（vec3）
- right
- up



**交互操作分两部分：**

位置移动：WASD

视角移动：鼠标





视角移动这里用欧拉角表示旋转，一共有三种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)

![image-20240625135915414](Study.assets/image-20240625135915414.png)









## 颜色

现实世界中有无数种颜色，我们需要用（有限的）数值来模拟（无限）的颜色，所以并不是所有现实世界中的颜色都可以用数值来表示！

颜色可以数字化的由红色(Red)、绿色(Green)和蓝色(Blue)三个分量组成，它们通常被缩写为RGB！



在现实生活中，某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的(Reflected)颜色！

也就是说，那些不能被物体吸收的颜色就是我们能够感知到的物体颜色！



**举个例子：**如果将白光照在一个蓝色玩具上，这个玩具会吸收白光中除了蓝色以外的所有颜色，不被吸收的蓝色被反射到我们的眼中，因此看起来是蓝色！



再看个图：

![image-20240625153932886](Study.assets/image-20240625153932886.png)



当在OpenGL中创建一个光源时，我们给光源一个颜色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色！



举个例子：

```glsl
glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
glm::vec3 toyColor(1.0f, 0.5f, 0.31f);
glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f);
```



因此，物体的颜色，本质上含义：**从光源反射各个颜色分量的系数**







**基础光照**

现实世界的光照是极其复杂，有限的计算能力所无法模拟。

OpenGL的光照使用的是简化的模型，对现实的情况进行近似，其中一个模型被称为冯氏光照模型。

冯氏光照模型的主要结构由3个分量组成：

- 环境(Ambient)
- 漫反射(Diffuse)
- 镜面反射(Specular)

如下所示：

![image-20240625163349195](Study.assets/image-20240625163349195.png)



Ambient环境光：物体即使黑暗环境下最基本的颜色

Diffuse漫反射：模拟光源对物体的方向性影响，是冯氏光照模型中视觉上最显著的分量

Specular镜面反射：所谓的高光







**注意：**方向向量的w分量，例如法向量，w必须设置为0.0f，必须屏幕位移对之的影响！





**计算漫反射光照需要什么？**

- 法向量
- 定向的光线（光源的位置与片段的位置之间向量差）



**计算镜面反射需要什么？**

- 法向量
- 光照定向的光线（光源的位置与片段的位置之间向量差）
- 视线定向的光线（光源的位置与观察位置之间向量差）

















